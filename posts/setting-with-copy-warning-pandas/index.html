<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>SettingWithCopyWarning in pandas | Tan Nian Wei</title>
<meta name=keywords content="python,pandas">
<meta name=description content="What it is, why it crops up, and how to get rid of it">
<meta name=author content>
<link rel=canonical href=https://tnwei.github.io/posts/setting-with-copy-warning-pandas/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style>
<link rel=icon href=https://tnwei.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://tnwei.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://tnwei.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://tnwei.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://tnwei.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TCJ4MGEGS8"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-TCJ4MGEGS8')</script>
<meta property="og:title" content="SettingWithCopyWarning in pandas">
<meta property="og:description" content="What it is, why it crops up, and how to get rid of it">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-30T00:40:54+08:00">
<meta property="article:modified_time" content="2021-12-30T00:40:54+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="SettingWithCopyWarning in pandas">
<meta name=twitter:description content="What it is, why it crops up, and how to get rid of it">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tnwei.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SettingWithCopyWarning in pandas","item":"https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SettingWithCopyWarning in pandas","name":"SettingWithCopyWarning in pandas","description":"What it is, why it crops up, and how to get rid of it","keywords":["python","pandas"],"articleBody":"(tl;dr: jump straight to Getting rid of SettingWithCopyWarnings if you’re here for answers)\nIf you are a pandas user, chances are you’ve seen the SettingWithCopyWarning crop up when you’re assigning values to a pd.DataFrame or pd.Series.\nIn [1]: import pandas as pd ...: ...: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: }, index=range(5) ...: ) ...: dfa = df.loc[3:5] ...: dfa[\"C\"] = dfa[\"B\"] * 50 ipython-input-2-63497d1da3d9:9: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"C\"] = dfa[\"B\"] * 50 pandas drops a warning here because the value assignment might or might not have worked as expected.\nTo be clear, the value assignment did occur all right; the emphasis here is on “expected”.\nIn [2]: dfa Out[2]: A B C 3 4 9 450 4 5 10 500 In [3]: df Out[3]: A B 0 1 6 1 2 7 2 3 8 3 4 9 4 5 10 Did you expect the contents of df to be affected by the value assignment in dfa? pandas has internally consistent (albeit obtuse) rules on whether that happens or not. It’s just that the ambiguity in user expectations present in this situation warrants a warning, so that end users like you and me know where to look when our code misbehaves.\nChained assignment with views and copies The act of selecting rows or columns to access from a dataframe or series is called indexing. The flexibility of pandas allows for chained indexing, where you can repeatedly index the outcome of a previous indexing operation.\n# Select the 2nd to 4th row of data where col A  3 and col B != 7 df[df[\"A\"]  3 \u0026 df[\"B\"] != 7].iloc[3:5] pandas will then return either a view or a copy of the dataframe. A view (shallow copy) references data from the original dataframe, while a copy (deep copy) is a separate instance of the same data.\nIt is difficult to predict which will be returned by the indexing operation, as it depends on the memory layout of the underlying array. How exactly the indexing is chained can lead to different __getitem__ and __setitem__ calls being issued under the hood. Reproducing an example below:\n# Example borrowed from [1] dfmi.loc[:, ('one', 'second')] = value # becomes dfmi.loc.__setitem__((slice(None), ('one', 'second')), value) dfmi['one']['second'] = value # becomes dfmi.__getitem__('one').__setitem__('second', value) Chain indexing inherently is not a problem, but assigning values using chained indexing, i.e. chained assignment, can be. Depending on the situation, chained assignment will either modify the original dataframe directly, or return a modified copy of the original dataframe. This can lead to insidious bugs when it is not obvious that chained indexing has occured.\nChained indexing can take places across a few lines of code:\n# The following doesn't look like chain indexing, does it? dfa = df.loc[row1:row2, col1:col2] ... ... dfa[row2] = dfa[row1].apply(fn) If pandas did not raise a warning in this scenario, it would not be obvious that df is not modified by the second value assignment. This is why the SettingWithCopyWarning exists.\npandas docs 1 go into this with more detail. The warning message helpfully links to it, which is great because if you search pandas settingwithcopywarning on Google, the docs page is easy to miss! At time of writing, it is the 7th result on the first page of Google, and is crowded out by blogposts and StackOverflow questions.\nPeeking under the hood using the internal API Chained indexing is a godsend of convenience for selecting the right data, but chained assignment is a minefield for assigning the correct values. The TowardsDataScience article in 2 has a nice example where inverting the order of chained indexing alone is the difference between whether an assignment to the original dataframe occurs or not:\n# Example borrowed from [2] # This updates `df` df[\"product_group\"][df[\"product_group\"]==\"PG4\"] = \"PG14\" # This doesn't! df[df[\"product_group\"]==\"PG4\"][\"product_group\"] = \"PG14\" # pandas raises warnings for both # the user needs to confirm the intended outcome From this StackOverflow post, pd.DataFrame and pd.Series objects have _is_view and _is_copy attributes as part of their internal API. _is_view returns True if the object is a view, and False if the object is not. _is_copy stores either a weak reference to the dataframe it is copied from, or None if it is not associated to an existing dataframe.\nPrinting these internal attributes while poking around with chained assignment does reveal some interesting tidbits of info. On one hand, pandas uses _is_copy to decide if a SettingWithCopyWarning needs to be raised. On the other hand, modifying a dataframe with _is_view = True means that it will affect the original underlying dataframe.\nBefore we begin, a disclaimer: internal APIs are not meant to be accessed by the end user and are subject to change, use them at your own risk.\nIn [4]: pd.__version__ Out[4]: '1.3.3' # Setting up convenience functions In [5]: def make_clean_df(): ...: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5) ...: ) ...: return df In [6]: def show_attrs(obj): ...: print(f\"view: {obj._is_view}, copy: {obj._is_copy}\") We’ll start by showing the _is_view and _is_copy attributes of a few common indexing methods.\nIn [7]: df = make_clean_df() In [8]: show_attrs(df.loc[3:5]) ...: show_attrs(df.iloc[3:5]) ...: show_attrs(df.loc[3:5, [\"A\", \"B\"]]) ...: show_attrs(df.iloc[3:5, [0, 1]]) ...: show_attrs(df[\"A\"]) ...: show_attrs(df.loc[:, \"A\"]) view: True, copy: weakref at 0x7f4d648b2590; to 'DataFrame' at 0x7f4d648b54c0 view: True, copy: weakref at 0x7f4d648b2590; to 'DataFrame' at 0x7f4d648b54c0 view: False, copy: None view: False, copy: weakref at 0x7f4d648be770; dead view: True, copy: None view: True, copy: None Let’s break this down:\n Both df.loc[3:5] and df.iloc[3:5] returned views and have references to the original dataframe. For df.loc[3:5, [\"A\", \"B\"]] and df.iloc[3:5, [0, 1]] , when the columns are additionally specified on top of the rows, copies of df are returned instead. Using .loc indexing has no references to the OG dataframe, while using iloc indexing results in a reference to a temporary dataframe that has been garbage collected, which is as good as None itself. We’ll see if this carries any significance. Referring to a column directly using either df[\"A\"] or df.loc[:, \"A\"] returns a view, with no reference to the original dataframe. It might have to do with the fact that each dataframe column is actually stored as a pd Series.  What happens if we manually create copies of these indexed dataframes / series?\nIn [9]: show_attrs(df.loc[3:5].copy()) ...: show_attrs(df.iloc[3:5].copy()) ...: show_attrs(df.loc[3:5, [\"A\", \"B\"]].copy()) ...: show_attrs(df.iloc[3:5, [0, 1]].copy()) ...: show_attrs(df[\"A\"].copy()) ...: show_attrs(df.loc[:, \"A\"].copy()) view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None Explicitly calling .copy returns copies of data that have no reference to the original dataframe / series. Assigning data on these copies will not affect the original dataframe, and thus will not trigger SettingwithCopyWarnings. Given that df.loc[3:5, [\"A\", \"B\"]] and df.iloc[3:5, [0, 1]] above have similar attributes, we can expect that their behaviour under chained assignment should be similar to explicitly created copies.\nNext, we’ll try a few chained assignment scenarios.\nScenario 1: Specific rows indexed using loc The following three chained assignments raise SettingWithCopyWarnings:\nIn [10]: df = make_clean_df() ...: dfa = df.loc[3:5] ...: show_attrs(dfa) view: True, copy: weakref at 0x7fba308565e0; to 'DataFrame' at 0x7fba3084eac0 # (1a) In [11]: dfa[dfa % 2 == 0] = 100 /tmp/ipykernel_34555/3321004726.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[dfa % 2 == 0] = 100 /home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/ frame.py:3718: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy self._where(-key, value, inplace=True) # (1b) In [12]: dfa[\"D\"] = dfa[\"B\"] * 10 /tmp/ipykernel_34555/447367411.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"D\"] = dfa[\"B\"] * 10 # 1b # (1c) In [13]: dfa[\"A\"][3] = 10 /tmp/ipykernel_34555/1338713145.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"A\"][3] = 10 All of the value assignments took effect on dfa itself, but only (1a) and (1c) affected the original dataframe. (1b) did not.\nIn [14]: print(dfa) A B C D 3 10 9 100 90 4 5 100 15 1000 In [15]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 In addition, dfa is no longer a view, but a copy of the dataframe!\nIn [16]: show_attrs(dfa) # view changed to False view: False, copy: weakref at 0x7fba308565e0; to 'DataFrame' at 0x7fba3084eac0 What this tells us is that pandas will convert a view to a copy when necessary. This further shows why figuring out chained assignment is inherently tricky, and is difficult to cater for automatically at the library level.\nScenario 2: Specific rows indexed using iloc This is the same as scenario 1, but using iloc instead.\nIn [17]: df = make_clean_df() ...: dfb = df.iloc[3:5] ...: show_attrs(dfb) view: True, copy: weakref at 0x7fba30862040; to 'DataFrame' at 0x7fba30868c10 # (1a) In [18]: dfb[dfb % 2 == 0] = 100 /tmp/ipykernel_34555/734837801.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[dfb % 2 == 0] = 100 /home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/ frame.py:3718: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy self._where(-key, value, inplace=True) # (1b) In [19]: dfb[\"D\"] = dfb[\"B\"] * 10 /tmp/ipykernel_34555/4288697762.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[\"D\"] = dfb[\"B\"] * 10 # (1c) In [20]: dfb[\"A\"][3] = 10 /tmp/ipykernel_34555/2062795903.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[\"A\"][3] = 10 The observed outcome is the same as Scenario 1.\nIn [21]: print(dfb) A B C D 3 10 9 100 90 4 5 100 15 1000 In [22]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 In [23]: show_attrs(dfb) view: False, copy: weakref at 0x7fba30862040; to 'DataFrame' at 0x7fba30868c10 Scenario 3: Specific rows and columns indexed using loc Same as Scenario 1, but the columns are specified as well.\nIn [24]: df = make_clean_df() ...: dfc = df.loc[3:5, [\"A\", \"B\"]] ...: show_attrs(dfc) view: False, copy: None In [25]: dfc[dfc % 2 == 0] = 100 # No warnings raised ...: dfc[\"D\"] = dfc[\"B\"] * 10 ...: dfc[\"A\"][3] = 10 No warnings raised. All changes took effect on dfc without impacting df.\nIn [26]: print(dfc) A B D 3 10 9 90 4 5 100 1000 In [27]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 The chained assignment outcome is different, while the data indexed is the same as in Scenario 1. My guess is that a more complete description of the indexing operation prompted pandas to directly return a copy upfront, instead of a view that is linked to the original dataframe.\nScenario 4: Specific rows and columns indexed using iloc This is similar to Scenario 3, but using iloc instead. Given the past few scenarios, it is no surprise that this scenario had the same outcome as Scenario 3.\nIn [28]: df = make_clean_df() ...: dfd = df.iloc[3:5, [0, 1]] ...: show_attrs(dfd) view: False, copy: weakref at 0x7fba306f29f0; dead In [29]: dfd[dfd % 2 == 0] = 100 # No warnings raised ...: dfd[\"D\"] = dfd[\"B\"] * 10 ...: dfd[\"A\"][3] = 10 In [30]: print(dfd) A B D 3 10 9 90 4 5 100 1000 In [31]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 4 9 14 4 5 10 15 In addition, dfd discarded the reference to the garbage-collected dataframe at the end of this code.\nIn [32]: show_attrs(dfd) view: False, copy: None Scenario 5: Directly referring to a column of a dataframe This scenario tests chained assignment on series.\nIn [33]: df = make_clean_df() ...: dfe = df[\"A\"] ...: show_attrs(dfe) view: True, copy: None In [34]: dfe[1] = 99999 # No warnings raised ...: dfe.loc[2:4] = 88888 dfe remained a view of df[\"A\"]. All changes effected on dfe is reflected in df[\"A\"] , which is still part of df. It appears that there’s not much to worry about for chained assignment on individual series.\nIn [35]: print(dfe) 0 1 1 99999 2 88888 3 88888 4 88888 Name: A, dtype: int64 In [36]: print(df) A B C 0 1 6 11 1 99999 7 12 2 88888 8 13 3 88888 9 14 4 88888 10 15 In [37]: show_attrs(dfe) view: True, copy: None Getting rid of SettingWithCopyWarnings SettingWithCopyWarnings pop up when pandas isn’t sure if you want value assignment to affect the original dataframe or not. Therefore, getting rid of these warnings entails avoiding ambiguity in value assignment. As seen from the code samples above, getting pandas to return copies with no reference to the original dataframe is a clean way to ensure that values will not be written to the original dataframe unintended.\nI’ve found this to be a unifying thread across the solutions I came across when researching this topic. Summarizing them below:\nDisabling the warnings If you know what you’re doing and your code is behaving as intended, you can choose to suppress the warnings by disabling them 3:\n# Example borrowed from [^3] # Disables SettingWithCopyWarning globally pd.set_option('mode.chained_assignment', None) # Resets the warning option to default pd.reset_option('mode.chained_assignment') # Disables SettingWithCopyWarning locally within a context manager with pd.option_context('mode.chained_assignment', None): # YOUR CODE HERE Alternatively, you can suppress the warnings by setting the dataframe _is_copy attribute to None 3.\n# Example modified from [3] In [38]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) ...: ...: dfa = df.loc[3:5] ...: print(dfa._is_copy) weakref at 0x7f4d64792810; to 'DataFrame' at 0x7f4d64784460 In [39]: dfa._is_copy = None ...: dfa[\"D\"] = dfa[\"B\"] * 10 # No warning raised Remember that making the warnings go away doesn’t resolve wonky chained assignment issues. Chained assignment is a minefield where you might or might not step on a landmine. Disabling the warnings is like removing the minefield warning signs. Food for thought.\nMaking the warnings not show up in the first place When you run into a SettingWithCopy warning, take a moment to trace the chained assignment and decide if you want to modify the original dataframe directly, or have values assigned to a copy of the dataframe.\nWorking on the original dataframe Use .loc indexing to directly assign values to the dataframe.\n# Modified from examples in [2] In [40]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) ...: ...: df.loc[df[\"A\"] % 2 != 0, \"B\"] = df.loc[df[\"A\"] % 2 != 0, \"B\"] + 0.5 ...: print(df) A B C 0 1 6.5 11 1 2 7.0 12 2 3 8.5 13 3 4 9.0 14 4 5 10.5 15 pandas docs recommend this method for two reasons:\n using .loc is guaranteed to refer to the underlying dataframe it is called on. .iloc does not have this property. .loc indexing replaces what could be chain indexing into a single indexing step. If you refer to the example above under Chained assignment with views and copies, .loc indexing resolves chained indexing into a single __setitem__ call.  If you are selecting data using conditionals, you can consider returning a mask instead of a copy of the original dataframe. A mask is a boolean series or dataframe which can conveniently be used in .loc indexing, as the example below:\n# Modified from examples in [5] In [41]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) In [42]: dfa = (df[\"A\"]  3) \u0026 (df[\"C\"] == 12) In [43]: df.loc[dfa, \"B\"] = 99 # dfa can be fed into the loc index! In [44]: print(df) # changes took place in the original dataframe A B C 0 1 6 11 1 2 99 12 2 3 8 13 3 4 9 14 4 5 10 15 Working on the original dataframe directly can be tricky if existing indexing logic is complex. In that case, you can always use one of the methods from the next section to return a copy, then assign it back to the original dataframe 4.\nAssigning values to an explicit copy of the dataframe Use assign, where and replace:\nIn [45]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) # 1. Use the `assign` method to add columns In [46]: df = df.assign(D=df[\"C\"] * 10) ...: df = df.assign(**{\"D\": df[\"C\"] * 10}) # allows passing variables as names # 2. Use the `where` method to select values using conditionals and replace them # Modified from examples in [2] In [47]: df[\"B\"] = df[\"B\"].where( ...: df[\"A\"]  2, df[\"B\"] * 10 ...: ) # 3. Use the `replace` method to select and replace values in the dataframe # Modified from examples in [2] In [48]: df = df.replace({\"A\" : 1}, 100) In [49]: print(df) A B C D 0 100 6 11 110 1 2 70 12 120 2 3 80 13 130 3 4 90 14 140 4 5 100 15 150 Break down chained assignment steps into single assignments 5:\n# Examples borrowed from [4] # Not these df[\"z\"][mask] = 0 df.loc[mask][\"z\"] = 0 # But this df.loc[mask, \"z\"] = 0 A less elegant but foolproof method is to manually create a copy of the original dataframe and work on it instead 2. As long as you don’t introduce additional chained indexing, you will not see the SettingWithCopyWarning.\nIn [50]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) In [51]: dfa = df.loc[3:5].copy() # Added .copy() here ...: dfa.loc[3, \"A\"] = 10 # causes this line to raise no warning Redoing some of the examples above without triggering SettingWithCopy warnings Replace a chained assignment with where:\n# (i) df = make_clean_df() dfa = df.loc[3:5] # Original that raises warning # dfa[dfa % 2 == 0] = 100 dfa = dfa.where(dfa % 2 != 0, 100) # df is not affected Replace creating a new column on the indexed dataframe with assign:\n# (ii)  df = make_clean_df() # Original that raises warning # dfa[\"D\"] = dfa[\"B\"] * 10 dfa = dfa.assign(D=dfa[\"B\"]*10) # df is not affected Creating a copy of the dataframe, before assigning values using .loc indexing:\n# (iii) df = make_clean_df() # Original that raises warnings # dfa = df.loc[3:5] # dfa[\"A\"][3] = 10 # Create a copy then do loc indexing dfa = df.loc[3:5].copy() dfa.loc[3, \"A\"] = 10 Note that directly assigning values to dfa using .loc indexing will still raise a warning, as it is ambiguous if the assignment to dfa should also affect df.\nTruly rooting out SettingWithCopyWarnings Personally, I am a fan of promoting SettingWithCopyWarnings to SettingWithCopyExceptions for important scripts, using the following code:\npd.set_option('mode.chained_assignment', \"raise\") Doing this forces chained assignment to be dealt with, rather than allowing warnings to accumulate.\nIn my experience, cleaning up notebooks with stderr clogged by SettingWithCopyWarnings is its special kind of zen. I wholeheartedly recommend it.\n  Official pandas docs on chained assignment. https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy ↩︎\n TowardsDataScience article that briefly touches on a few ways to deal with the SettingWithCopy warnings. https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08 ↩︎\n In-depth article on this topic by DataQuest. Notably, there is a section dedicated to the history of dealing with chained assignment in pandas. https://www.dataquest.io/blog/settingwithcopywarning/ ↩︎\n StackOverflow post that contains more chained assignment examples. https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe ↩︎\n RealPython article covering this topic. For me, RealPython is a trusted goto reference second to official library docs. This article further goes into depth on the underlying view vs copy mechanisms in pandas, and in numpy, which pandas depends on. https://realpython.com/pandas-settingwithcopywarning/ ↩︎\n   ","wordCount":"3497","inLanguage":"en","datePublished":"2021-12-30T00:40:54+08:00","dateModified":"2021-12-30T00:40:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"},"publisher":{"@type":"Organization","name":"Tan Nian Wei","logo":{"@type":"ImageObject","url":"https://tnwei.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://tnwei.github.io/ accesskey=h title="Tan Nian Wei (Alt + H)">Tan Nian Wei</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://tnwei.github.io/writing/ title=Writing>
<span>Writing</span>
</a>
</li>
<li>
<a href=https://drive.google.com/file/d/1y6VzyE8ocY0O2Qw_LGmoGPUBKzqBd0ls/view title=Resume>
<span>Resume</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
SettingWithCopyWarning in pandas
</h1>
<div class=post-meta><span title="2021-12-30 00:40:54 +0800 +0800">Dec 30, 2021 Thu</span>&nbsp;·&nbsp;17 min
</div>
</header>
<div class=post-content><p>(tl;dr: jump straight to <a href=#getting-rid-of-settingwithcopywarnings title="Getting rid of SettingWithCopyWarnings">Getting rid of SettingWithCopyWarnings</a> if you’re here for answers)</p>
<p>If you are a pandas user, chances are you’ve seen the SettingWithCopyWarning crop up when you’re assigning values to a <code>pd.DataFrame</code> or <code>pd.Series</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>1</span>]: <span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
   <span style=color:#f92672>...</span>:
   <span style=color:#f92672>...</span>: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
   <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
   <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
   <span style=color:#f92672>...</span>:      }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>)
   <span style=color:#f92672>...</span>: )
   <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
   <span style=color:#f92672>...</span>: dfa[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>

<span style=color:#f92672>&lt;</span>ipython<span style=color:#f92672>-</span>input<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>-</span><span style=color:#ae81ff>63497</span>d1da3d9<span style=color:#f92672>&gt;</span>:<span style=color:#ae81ff>9</span>: SettingWithCopyWarning:
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfa[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>
</code></pre></div><p>pandas drops a warning here because the value assignment might or might not have worked as expected.</p>
<p>To be clear, the value assignment did occur all right; the emphasis here is on “expected”.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>2</span>]: dfa
Out[<span style=color:#ae81ff>2</span>]:
   A   B    C
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>450</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>500</span>

In [<span style=color:#ae81ff>3</span>]: df
Out[<span style=color:#ae81ff>3</span>]:
   A   B
<span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>
<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7</span>
<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>
</code></pre></div><p>Did you expect the contents of <code>df</code> to be affected by the value assignment in <code>dfa</code>? pandas has internally consistent (albeit obtuse) rules on whether that happens or not. It’s just that the ambiguity in user expectations present in this situation warrants a warning, so that end users like you and me know where to look when our code misbehaves.</p>
<h2 id=chained-assignment-with-views-and-copies>Chained assignment with views and copies<a hidden class=anchor aria-hidden=true href=#chained-assignment-with-views-and-copies>#</a></h2>
<p>The act of selecting rows or columns to access from a dataframe or series is called <em>indexing</em>. The flexibility of pandas allows for chained indexing, where you can repeatedly index the outcome of a previous indexing operation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Select the 2nd to 4th row of data where col A &gt; 3 and col B != 7</span>
df[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;</span> df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>7</span>]<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</code></pre></div><p>pandas will then return either a view or a copy of the dataframe. A view (shallow copy) references data from the original dataframe, while a copy (deep copy) is a separate instance of the same data.</p>
<p>It is difficult to predict which will be returned by the indexing operation, as it depends on the memory layout of the underlying array. How exactly the indexing is chained can lead to different <code>__getitem__</code> and <code>__setitem__</code> calls being issued under the hood. Reproducing an example below:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Example borrowed from [1]</span>

dfmi<span style=color:#f92672>.</span>loc[:, (<span style=color:#e6db74>&#39;one&#39;</span>, <span style=color:#e6db74>&#39;second&#39;</span>)] <span style=color:#f92672>=</span> value
<span style=color:#75715e># becomes</span>
dfmi<span style=color:#f92672>.</span>loc<span style=color:#f92672>.</span>__setitem__((slice(<span style=color:#66d9ef>None</span>), (<span style=color:#e6db74>&#39;one&#39;</span>, <span style=color:#e6db74>&#39;second&#39;</span>)), value)

dfmi[<span style=color:#e6db74>&#39;one&#39;</span>][<span style=color:#e6db74>&#39;second&#39;</span>] <span style=color:#f92672>=</span> value
<span style=color:#75715e># becomes</span>
dfmi<span style=color:#f92672>.</span>__getitem__(<span style=color:#e6db74>&#39;one&#39;</span>)<span style=color:#f92672>.</span>__setitem__(<span style=color:#e6db74>&#39;second&#39;</span>, value)
</code></pre></div><p>Chain indexing inherently is not a problem, but assigning values using chained indexing, i.e. <em>chained assignment</em>, can be. Depending on the situation, chained assignment will either modify the original dataframe directly, or return a modified copy of the original dataframe. This can lead to insidious bugs when it is not obvious that chained indexing has occured.</p>
<p>Chained indexing can take places across a few lines of code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># The following doesn&#39;t look like chain indexing, does it?</span>
dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[row1:row2, col1:col2]
<span style=color:#f92672>...</span>
<span style=color:#f92672>...</span>
dfa[row2] <span style=color:#f92672>=</span> dfa[row1]<span style=color:#f92672>.</span>apply(fn)
</code></pre></div><p>If pandas did not raise a warning in this scenario, it would not be obvious that <code>df</code> is not modified by the second value assignment. This is why the SettingWithCopyWarning exists.</p>
<p>pandas docs <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> go into this with more detail. The warning message helpfully links to it, which is great because if you search <code>pandas settingwithcopywarning</code> on Google, the docs page is easy to miss! At time of writing, it is the 7th result on the first page of Google, and is crowded out by blogposts and StackOverflow questions.</p>
<h2 id=peeking-under-the-hood-using-the-internal-api>Peeking under the hood using the internal API<a hidden class=anchor aria-hidden=true href=#peeking-under-the-hood-using-the-internal-api>#</a></h2>
<p>Chained indexing is a godsend of convenience for selecting the right data, but chained assignment is a minefield for assigning the correct values. The TowardsDataScience article in <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> has a nice example where inverting the order of chained indexing alone is the difference between whether an assignment to the original dataframe occurs or not:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Example borrowed from [2]</span>

<span style=color:#75715e># This updates `df`</span>
df[<span style=color:#e6db74>&#34;product_group&#34;</span>][df[<span style=color:#e6db74>&#34;product_group&#34;</span>]<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;PG4&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;PG14&#34;</span>

<span style=color:#75715e># This doesn&#39;t!</span>
df[df[<span style=color:#e6db74>&#34;product_group&#34;</span>]<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;PG4&#34;</span>][<span style=color:#e6db74>&#34;product_group&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;PG14&#34;</span>

<span style=color:#75715e># pandas raises warnings for both</span>
<span style=color:#75715e># the user needs to confirm the intended outcome</span>
</code></pre></div><p>From <a href=https://stackoverflow.com/questions/26879073/checking-whether-data-frame-is-copy-or-view-in-pandas>this StackOverflow post</a>, <code>pd.DataFrame</code> and <code>pd.Series</code> objects have <code>_is_view</code> and <code>_is_copy</code> attributes as part of their internal API. <code>_is_view</code> returns True if the object is a view, and False if the object is not. <code>_is_copy</code> stores either a <a href=https://docs.python.org/3/library/weakref.html>weak reference</a> to the dataframe it is copied from, or <code>None</code> if it is not associated to an existing dataframe.</p>
<p>Printing these internal attributes while poking around with chained assignment does reveal some interesting tidbits of info. On one hand, pandas uses <code>_is_copy</code> to decide if a SettingWithCopyWarning needs to be raised. On the other hand, modifying a dataframe with <code>_is_view</code> = True means that it will affect the original underlying dataframe.</p>
<p>Before we begin, a disclaimer: internal APIs are not meant to be accessed by the end user and are subject to change, use them at your own risk.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>4</span>]: pd<span style=color:#f92672>.</span>__version__
Out[<span style=color:#ae81ff>4</span>]: <span style=color:#e6db74>&#39;1.3.3&#39;</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Setting up convenience functions</span>
In [<span style=color:#ae81ff>5</span>]: <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_clean_df</span>():
   <span style=color:#f92672>...</span>:     df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
   <span style=color:#f92672>...</span>:          }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>)
   <span style=color:#f92672>...</span>:     )
   <span style=color:#f92672>...</span>:     <span style=color:#66d9ef>return</span> df

In [<span style=color:#ae81ff>6</span>]: <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>show_attrs</span>(obj):
   <span style=color:#f92672>...</span>:     print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;view: </span><span style=color:#e6db74>{</span>obj<span style=color:#f92672>.</span>_is_view<span style=color:#e6db74>}</span><span style=color:#e6db74>, copy: </span><span style=color:#e6db74>{</span>obj<span style=color:#f92672>.</span>_is_copy<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>We’ll start by showing the <code>_is_view</code> and <code>_is_copy</code> attributes of a few common indexing methods.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>7</span>]: df <span style=color:#f92672>=</span> make_clean_df()

In [<span style=color:#ae81ff>8</span>]: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>])
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>])
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]])
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]])
   <span style=color:#f92672>...</span>: show_attrs(df[<span style=color:#e6db74>&#34;A&#34;</span>])
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[:, <span style=color:#e6db74>&#34;A&#34;</span>])

view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648b2590</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d648b54c0</span><span style=color:#f92672>&gt;</span>
view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648b2590</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d648b54c0</span><span style=color:#f92672>&gt;</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648be770</span>; dead<span style=color:#f92672>&gt;</span>
view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</code></pre></div><p>Let’s break this down:</p>
<ul>
<li>Both <code>df.loc[3:5]</code> and <code>df.iloc[3:5]</code> returned views and have references to the original dataframe.</li>
<li>For <code>df.loc[3:5, ["A", "B"]]</code> and <code>df.iloc[3:5, [0, 1]]</code> , when the columns are additionally specified on top of the rows, copies of <code>df</code> are returned instead. Using <code>.loc</code> indexing has no references to the OG dataframe, while using <code>iloc</code> indexing results in a reference to a temporary dataframe that has been garbage collected, which is as good as <code>None</code> itself. We’ll see if this carries any significance.</li>
<li>Referring to a column directly using either <code>df["A"]</code> or <code>df.loc[:, "A"]</code> returns a view, with no reference to the original dataframe. It might have to do with the fact that each dataframe column is actually stored as a <code>pd Series</code>.</li>
</ul>
<p>What happens if we manually create copies of these indexed dataframes / series?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>9</span>]: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy())
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy())
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]]<span style=color:#f92672>.</span>copy())
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]]<span style=color:#f92672>.</span>copy())
   <span style=color:#f92672>...</span>: show_attrs(df[<span style=color:#e6db74>&#34;A&#34;</span>]<span style=color:#f92672>.</span>copy())
   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[:, <span style=color:#e6db74>&#34;A&#34;</span>]<span style=color:#f92672>.</span>copy())

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</code></pre></div><p>Explicitly calling <code>.copy</code> returns copies of data that have no reference to the original dataframe / series. Assigning data on these copies will not affect the original dataframe, and thus will not trigger SettingwithCopyWarnings. Given that <code>df.loc[3:5, ["A", "B"]]</code> and <code>df.iloc[3:5, [0, 1]]</code> above have similar attributes, we can expect that their behaviour under chained assignment should be similar to explicitly created copies.</p>
<p>Next, we’ll try a few chained assignment scenarios.</p>
<h3 id=scenario-1-specific-rows-indexed-using-loc>Scenario 1: Specific rows indexed using loc<a hidden class=anchor aria-hidden=true href=#scenario-1-specific-rows-indexed-using-loc>#</a></h3>
<p>The following three chained assignments raise SettingWithCopyWarnings:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>10</span>]: df <span style=color:#f92672>=</span> make_clean_df()
    <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
    <span style=color:#f92672>...</span>: show_attrs(dfa)

view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba308565e0</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba3084eac0</span><span style=color:#f92672>&gt;</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1a)</span>
In [<span style=color:#ae81ff>11</span>]: dfa[dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>3321004726.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfa[dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
<span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>tnwei<span style=color:#f92672>/</span>miniconda3<span style=color:#f92672>/</span>envs<span style=color:#f92672>/</span>ml<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>python3<span style=color:#ae81ff>.9</span><span style=color:#f92672>/</span>site<span style=color:#f92672>-</span>packages<span style=color:#f92672>/</span>pandas<span style=color:#f92672>/</span>core<span style=color:#f92672>/</span>
frame<span style=color:#f92672>.</span>py:<span style=color:#ae81ff>3718</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  self<span style=color:#f92672>.</span>_where(<span style=color:#f92672>-</span>key, value, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1b)</span>
In [<span style=color:#ae81ff>12</span>]: dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>447367411.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> <span style=color:#75715e># 1b</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1c)</span>
In [<span style=color:#ae81ff>13</span>]: dfa[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>1338713145.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfa[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><p>All of the value assignments took effect on <code>dfa</code> itself, but only (1a) and (1c) affected the original dataframe. (1b) did not.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>14</span>]: print(dfa)
 
A    B    C     D
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>90</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>1000</span>

In [<span style=color:#ae81ff>15</span>]: print(df)

A    B    C
<span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>
</code></pre></div><p>In addition, <code>dfa</code> is no longer a view, but a copy of the dataframe!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>16</span>]: show_attrs(dfa) <span style=color:#75715e># view changed to False</span>

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba308565e0</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba3084eac0</span><span style=color:#f92672>&gt;</span>
</code></pre></div><p>What this tells us is that pandas will convert a view to a copy when necessary. This further shows why figuring out chained assignment is inherently tricky, and is difficult to cater for automatically at the library level.</p>
<h3 id=scenario-2-specific-rows-indexed-using-iloc>Scenario 2: Specific rows indexed using iloc<a hidden class=anchor aria-hidden=true href=#scenario-2-specific-rows-indexed-using-iloc>#</a></h3>
<p>This is the same as scenario 1, but using <code>iloc</code> instead.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>17</span>]: df <span style=color:#f92672>=</span> make_clean_df()
    <span style=color:#f92672>...</span>: dfb <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
    <span style=color:#f92672>...</span>: show_attrs(dfb)

view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba30862040</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba30868c10</span><span style=color:#f92672>&gt;</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1a)</span>
In [<span style=color:#ae81ff>18</span>]: dfb[dfb <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>734837801.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfb[dfb <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
<span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>tnwei<span style=color:#f92672>/</span>miniconda3<span style=color:#f92672>/</span>envs<span style=color:#f92672>/</span>ml<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>python3<span style=color:#ae81ff>.9</span><span style=color:#f92672>/</span>site<span style=color:#f92672>-</span>packages<span style=color:#f92672>/</span>pandas<span style=color:#f92672>/</span>core<span style=color:#f92672>/</span>
frame<span style=color:#f92672>.</span>py:<span style=color:#ae81ff>3718</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  self<span style=color:#f92672>.</span>_where(<span style=color:#f92672>-</span>key, value, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1b)</span>
In [<span style=color:#ae81ff>19</span>]: dfb[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfb[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>4288697762.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfb[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfb[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (1c)</span>
In [<span style=color:#ae81ff>20</span>]: dfb[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>

<span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>2062795903.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame

See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
  dfb[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><p>The observed outcome is the same as Scenario 1.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>21</span>]: print(dfb)

A    B    C     D
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>90</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>1000</span>

In [<span style=color:#ae81ff>22</span>]: print(df)

A    B    C
<span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>

In [<span style=color:#ae81ff>23</span>]: show_attrs(dfb)

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba30862040</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba30868c10</span><span style=color:#f92672>&gt;</span>
</code></pre></div><h3 id=scenario-3-specific-rows-and-columns-indexed-using-loc>Scenario 3: Specific rows and columns indexed using loc<a hidden class=anchor aria-hidden=true href=#scenario-3-specific-rows-and-columns-indexed-using-loc>#</a></h3>
<p>Same as Scenario 1, but the columns are specified as well.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>24</span>]: df <span style=color:#f92672>=</span> make_clean_df()
    <span style=color:#f92672>...</span>: dfc <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]]
    <span style=color:#f92672>...</span>: show_attrs(dfc)

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>

In [<span style=color:#ae81ff>25</span>]: dfc[dfc <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#75715e># No warnings raised</span>
    <span style=color:#f92672>...</span>: dfc[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfc[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
    <span style=color:#f92672>...</span>: dfc[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><p>No warnings raised. All changes took effect on <code>dfc</code> without impacting <code>df</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>26</span>]: print(dfc)
 
A    B    D
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>   <span style=color:#ae81ff>90</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span> <span style=color:#ae81ff>1000</span>

In [<span style=color:#ae81ff>27</span>]: print(df)

A    B    C
<span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>
</code></pre></div><p>The chained assignment outcome is different, while the data indexed is the same as in Scenario 1. My guess is that a more complete description of the indexing operation prompted pandas to directly return a copy upfront, instead of a view that is linked to the original dataframe.</p>
<h3 id=scenario-4-specific-rows-and-columns-indexed-using-iloc>Scenario 4: Specific rows and columns indexed using iloc<a hidden class=anchor aria-hidden=true href=#scenario-4-specific-rows-and-columns-indexed-using-iloc>#</a></h3>
<p>This is similar to Scenario 3, but using iloc instead. Given the past few scenarios, it is no surprise that this scenario had the same outcome as Scenario 3.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>28</span>]: df <span style=color:#f92672>=</span> make_clean_df()
    <span style=color:#f92672>...</span>: dfd <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]]
    <span style=color:#f92672>...</span>: show_attrs(dfd)

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba306f29f0</span>; dead<span style=color:#f92672>&gt;</span>

In [<span style=color:#ae81ff>29</span>]: dfd[dfd <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>  <span style=color:#75715e># No warnings raised</span>
    <span style=color:#f92672>...</span>: dfd[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfd[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
    <span style=color:#f92672>...</span>: dfd[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>

In [<span style=color:#ae81ff>30</span>]: print(dfd)

A    B     D
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>    <span style=color:#ae81ff>90</span>
<span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>  <span style=color:#ae81ff>1000</span>

In [<span style=color:#ae81ff>31</span>]: print(df)

A   B   C
<span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>
</code></pre></div><p>In addition, <code>dfd</code> discarded the reference to the garbage-collected dataframe at the end of this code.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>32</span>]: show_attrs(dfd)

view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</code></pre></div><h3 id=scenario-5-directly-referring-to-a-column-of-a-dataframe>Scenario 5: Directly referring to a column of a dataframe<a hidden class=anchor aria-hidden=true href=#scenario-5-directly-referring-to-a-column-of-a-dataframe>#</a></h3>
<p>This scenario tests chained assignment on series.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>33</span>]: df <span style=color:#f92672>=</span> make_clean_df()
    <span style=color:#f92672>...</span>: dfe <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;A&#34;</span>]
    <span style=color:#f92672>...</span>: show_attrs(dfe)

view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>

In [<span style=color:#ae81ff>34</span>]: dfe[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99999</span> <span style=color:#75715e># No warnings raised</span>
    <span style=color:#f92672>...</span>: dfe<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>88888</span>
</code></pre></div><p><code>dfe</code> remained a view of <code>df["A"]</code>. All changes effected on <code>dfe</code> is reflected in <code>df["A"]</code> , which is still part of <code>df</code>. It appears that there’s not much to worry about for chained assignment on individual series.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>35</span>]: print(dfe)

<span style=color:#ae81ff>0</span>        <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>99999</span>
<span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>88888</span>
<span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>88888</span>
<span style=color:#ae81ff>4</span>    <span style=color:#ae81ff>88888</span>
Name: A, dtype: int64

In [<span style=color:#ae81ff>36</span>]: print(df)

A   B   C
<span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>99999</span>   <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>88888</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>88888</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>88888</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>

In [<span style=color:#ae81ff>37</span>]: show_attrs(dfe)

view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</code></pre></div><h2 id=getting-rid-of-settingwithcopywarnings>Getting rid of SettingWithCopyWarnings<a hidden class=anchor aria-hidden=true href=#getting-rid-of-settingwithcopywarnings>#</a></h2>
<p>SettingWithCopyWarnings pop up when pandas isn’t sure if you want value assignment to affect the original dataframe or not. Therefore, getting rid of these warnings entails avoiding ambiguity in value assignment. As seen from the code samples above, getting pandas to return copies with no reference to the original dataframe is a clean way to ensure that values will not be written to the original dataframe unintended.</p>
<p>I’ve found this to be a unifying thread across the solutions I came across when researching this topic. Summarizing them below:</p>
<h3 id=disabling-the-warnings>Disabling the warnings<a hidden class=anchor aria-hidden=true href=#disabling-the-warnings>#</a></h3>
<p>If you know what you’re doing and your code is behaving as intended, you can choose to suppress the warnings by disabling them <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Example borrowed from [^3]</span>

<span style=color:#75715e># Disables SettingWithCopyWarning globally</span>
pd<span style=color:#f92672>.</span>set_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#66d9ef>None</span>)

<span style=color:#75715e># Resets the warning option to default</span>
pd<span style=color:#f92672>.</span>reset_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>)

<span style=color:#75715e># Disables SettingWithCopyWarning locally within a context manager</span>
<span style=color:#66d9ef>with</span> pd<span style=color:#f92672>.</span>option_context(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#66d9ef>None</span>):
    <span style=color:#75715e># YOUR CODE HERE</span>
</code></pre></div><p>Alternatively, you can suppress the warnings by setting the dataframe <code>_is_copy</code> attribute to <code>None</code> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Example modified from [3]</span>
In [<span style=color:#ae81ff>38</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
    <span style=color:#f92672>...</span>: 
    <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
    <span style=color:#f92672>...</span>: print(dfa<span style=color:#f92672>.</span>_is_copy)

<span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d64792810</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d64784460</span><span style=color:#f92672>&gt;</span>

In [<span style=color:#ae81ff>39</span>]: dfa<span style=color:#f92672>.</span>_is_copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
    <span style=color:#f92672>...</span>: dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># No warning raised</span>
</code></pre></div><p>Remember that making the warnings go away doesn’t resolve wonky chained assignment issues. Chained assignment is a minefield where you might or might not step on a landmine. Disabling the warnings is like removing the minefield warning signs. Food for thought.</p>
<h3 id=making-the-warnings-not-show-up-in-the-first-place>Making the warnings not show up in the first place<a hidden class=anchor aria-hidden=true href=#making-the-warnings-not-show-up-in-the-first-place>#</a></h3>
<p>When you run into a SettingWithCopy warning, take a moment to trace the chained assignment and decide if you want to modify the original dataframe directly, or have values assigned to a copy of the dataframe.</p>
<h4 id=working-on-the-original-dataframe>Working on the original dataframe<a hidden class=anchor aria-hidden=true href=#working-on-the-original-dataframe>#</a></h4>
<p>Use <code>.loc</code> indexing to directly assign values to the dataframe.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Modified from examples in [2]</span>
In [<span style=color:#ae81ff>40</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
    <span style=color:#f92672>...</span>:
    <span style=color:#f92672>...</span>: df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
    <span style=color:#f92672>...</span>: print(df)

   A     B   C
<span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6.5</span>  <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7.0</span>  <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8.5</span>  <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9.0</span>  <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10.5</span>  <span style=color:#ae81ff>15</span>
</code></pre></div><p>pandas docs recommend this method for two reasons:</p>
<ul>
<li>using <code>.loc</code> is guaranteed to refer to the underlying dataframe it is called on. <code>.iloc</code> does not have this property.</li>
<li><code>.loc</code> indexing replaces what could be chain indexing into a single indexing step. If you refer to the example above under <a href=#chained-assignment-with-views-and-copies title="Chained assignment with views and copies">Chained assignment with views and copies</a>, <code>.loc</code> indexing resolves chained indexing into a single <code>__setitem__</code> call.</li>
</ul>
<p>If you are selecting data using conditionals, you can consider returning a mask instead of a copy of the original dataframe. A mask is a boolean series or dataframe which can conveniently be used in <code>.loc</code> indexing, as the example below:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Modified from examples in [5]</span>
In [<span style=color:#ae81ff>41</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))

In [<span style=color:#ae81ff>42</span>]: dfa <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&amp;</span> (df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>12</span>)

In [<span style=color:#ae81ff>43</span>]: df<span style=color:#f92672>.</span>loc[dfa, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99</span> <span style=color:#75715e># dfa can be fed into the loc index!</span>

In [<span style=color:#ae81ff>44</span>]: print(df) <span style=color:#75715e># changes took place in the original dataframe</span>
   A   B   C
<span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>99</span>  <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
<span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>
</code></pre></div><p>Working on the original dataframe directly can be tricky if existing indexing logic is complex. In that case, you can always use one of the methods from the next section to return a copy, then assign it back to the original dataframe <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p>
<h4 id=assigning-values-to-an-explicit-copy-of-the-dataframe>Assigning values to an explicit copy of the dataframe<a hidden class=anchor aria-hidden=true href=#assigning-values-to-an-explicit-copy-of-the-dataframe>#</a></h4>
<p>Use <code>assign</code>, <code>where</code> and <code>replace</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>45</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))

<span style=color:#75715e># 1. Use the `assign` method to add columns</span>
In [<span style=color:#ae81ff>46</span>]: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>assign(D<span style=color:#f92672>=</span>df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>)
    <span style=color:#f92672>...</span>: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>assign(<span style=color:#f92672>**</span>{<span style=color:#e6db74>&#34;D&#34;</span>: df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>}) <span style=color:#75715e># allows passing variables as names</span>

<span style=color:#75715e># 2. Use the `where` method to select values using conditionals and replace them</span>
<span style=color:#75715e># Modified from examples in [2]</span>
In [<span style=color:#ae81ff>47</span>]: df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;B&#34;</span>]<span style=color:#f92672>.</span>where(
    <span style=color:#f92672>...</span>:     df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>, df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
    <span style=color:#f92672>...</span>: )

<span style=color:#75715e># 3. Use the `replace` method to select and replace values in the dataframe</span>
<span style=color:#75715e># Modified from examples in [2]</span>
In [<span style=color:#ae81ff>48</span>]: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>replace({<span style=color:#e6db74>&#34;A&#34;</span> : <span style=color:#ae81ff>1</span>}, <span style=color:#ae81ff>100</span>)

In [<span style=color:#ae81ff>49</span>]: print(df)
A    B   C    D
<span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>  <span style=color:#ae81ff>110</span>
<span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>70</span>  <span style=color:#ae81ff>12</span>  <span style=color:#ae81ff>120</span>
<span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>80</span>  <span style=color:#ae81ff>13</span>  <span style=color:#ae81ff>130</span>
<span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>90</span>  <span style=color:#ae81ff>14</span>  <span style=color:#ae81ff>140</span>
<span style=color:#ae81ff>4</span>    <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>  <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>150</span>
</code></pre></div><p>Break down chained assignment steps into single assignments <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Examples borrowed from [4]</span>
<span style=color:#75715e># Not these</span>
df[<span style=color:#e6db74>&#34;z&#34;</span>][mask] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
df<span style=color:#f92672>.</span>loc[mask][<span style=color:#e6db74>&#34;z&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

<span style=color:#75715e># But this</span>
df<span style=color:#f92672>.</span>loc[mask, <span style=color:#e6db74>&#34;z&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</code></pre></div><p>A less elegant but foolproof method is to manually create a copy of the original dataframe and work on it instead <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. As long as you don’t introduce additional chained indexing, you will not see the SettingWithCopyWarning.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>In [<span style=color:#ae81ff>50</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))

In [<span style=color:#ae81ff>51</span>]: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy() <span style=color:#75715e># Added .copy() here</span>
    <span style=color:#f92672>...</span>: dfa<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>     <span style=color:#75715e># causes this line to raise no warning</span>
</code></pre></div><h2 id=redoing-some-of-the-examples-above-without-triggering-settingwithcopy-warnings>Redoing some of the examples above without triggering SettingWithCopy warnings<a hidden class=anchor aria-hidden=true href=#redoing-some-of-the-examples-above-without-triggering-settingwithcopy-warnings>#</a></h2>
<p>Replace a chained assignment with <code>where</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (i)</span>
df <span style=color:#f92672>=</span> make_clean_df()
dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]

<span style=color:#75715e># Original that raises warning</span>
<span style=color:#75715e># dfa[dfa % 2 == 0] = 100</span>

dfa <span style=color:#f92672>=</span> dfa<span style=color:#f92672>.</span>where(dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>) <span style=color:#75715e># df is not affected</span>
</code></pre></div><p>Replace creating a new column on the indexed dataframe with <code>assign</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (ii) </span>
df <span style=color:#f92672>=</span> make_clean_df()

<span style=color:#75715e># Original that raises warning</span>
<span style=color:#75715e># dfa[&#34;D&#34;] = dfa[&#34;B&#34;] * 10</span>

dfa <span style=color:#f92672>=</span> dfa<span style=color:#f92672>.</span>assign(D<span style=color:#f92672>=</span>dfa[<span style=color:#e6db74>&#34;B&#34;</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>) <span style=color:#75715e># df is not affected</span>
</code></pre></div><p>Creating a copy of the dataframe, before assigning values using <code>.loc</code> indexing:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># (iii)</span>
df <span style=color:#f92672>=</span> make_clean_df()

<span style=color:#75715e># Original that raises warnings</span>
<span style=color:#75715e># dfa = df.loc[3:5]</span>
<span style=color:#75715e># dfa[&#34;A&#34;][3] = 10</span>

<span style=color:#75715e># Create a copy then do loc indexing</span>
dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy()
dfa<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><p>Note that directly assigning values to <code>dfa</code> using <code>.loc</code> indexing will still raise a warning, as it is ambiguous if the assignment to <code>dfa</code> should also affect <code>df</code>.</p>
<h2 id=truly-rooting-out-settingwithcopywarnings>Truly rooting out SettingWithCopyWarnings<a hidden class=anchor aria-hidden=true href=#truly-rooting-out-settingwithcopywarnings>#</a></h2>
<p>Personally, I am a fan of promoting SettingWithCopyWarnings to SettingWithCopyExceptions for important scripts, using the following code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>pd<span style=color:#f92672>.</span>set_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#e6db74>&#34;raise&#34;</span>)
</code></pre></div><p>Doing this forces chained assignment to be dealt with, rather than allowing warnings to accumulate.</p>
<p>In my experience, cleaning up notebooks with stderr clogged by SettingWithCopyWarnings is its special kind of zen. I wholeheartedly recommend it.</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>Official <code>pandas</code> docs on chained assignment.
<a href=https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy>https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>TowardsDataScience article that briefly touches on a few ways to deal with the SettingWithCopy warnings.
<a href=https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08>https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p>In-depth article on this topic by DataQuest. Notably, there is a section dedicated to the history of dealing with chained assignment in <code>pandas</code>.
<a href=https://www.dataquest.io/blog/settingwithcopywarning/>https://www.dataquest.io/blog/settingwithcopywarning/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p>StackOverflow post that contains more chained assignment examples. <a href=https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe>https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p>RealPython article covering this topic. For me, RealPython is a trusted goto reference second to official library docs. This article further goes into depth on the underlying view vs copy mechanisms in pandas, and in numpy, which pandas depends on.
<a href=https://realpython.com/pandas-settingwithcopywarning/>https://realpython.com/pandas-settingwithcopywarning/</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://tnwei.github.io/tags/python/>python</a></li>
<li><a href=https://tnwei.github.io/tags/pandas/>pandas</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on twitter" href="https://twitter.com/intent/tweet/?text=SettingWithCopyWarning%20in%20pandas&url=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f&hashtags=python%2cpandas"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f&title=SettingWithCopyWarning%20in%20pandas&summary=SettingWithCopyWarning%20in%20pandas&source=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f&title=SettingWithCopyWarning%20in%20pandas"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on whatsapp" href="https://api.whatsapp.com/send?text=SettingWithCopyWarning%20in%20pandas%20-%20https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share SettingWithCopyWarning in pandas on telegram" href="https://telegram.me/share/url?text=SettingWithCopyWarning%20in%20pandas&url=https%3a%2f%2ftnwei.github.io%2fposts%2fsetting-with-copy-warning-pandas%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://giscus.app/client.js data-repo=tnwei/tnwei.github.io data-repo-id=R_kgDOGmOfvQ data-category=Announcements data-category-id=DIC_kwDOGmOfvc4CAeit data-mapping=og:title data-reactions-enabled=0 data-emit-metadata=0 data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script>
<noscript></noscript>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://tnwei.github.io/>Tan Nian Wei</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>