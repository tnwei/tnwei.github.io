<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SettingWithCopyWarning in pandas | Tan Nian Wei</title><meta name=keywords content="python,pandas"><meta name=description content="What it is, why it crops up, and how to get rid of it"><meta name=author content><link rel=canonical href=https://tnwei.github.io/posts/setting-with-copy-warning-pandas/><link crossorigin=anonymous href=/assets/css/stylesheet.min.3f18978ad811c7ac935d52e17228171d2a4141b9d8c9c35a5899222d655e34b8.css integrity="sha256-PxiXitgRx6yTXVLhcigXHSpBQbnYycNaWJkiLWVeNLg=" rel="preload stylesheet" as=style><link rel=icon href=https://tnwei.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tnwei.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tnwei.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tnwei.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tnwei.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-TCJ4MGEGS8"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TCJ4MGEGS8")</script><style>figcaption{text-align:center}</style><meta property="og:title" content="SettingWithCopyWarning in pandas"><meta property="og:description" content="What it is, why it crops up, and how to get rid of it"><meta property="og:type" content="article"><meta property="og:url" content="https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-30T00:40:54+08:00"><meta property="article:modified_time" content="2021-12-30T00:40:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SettingWithCopyWarning in pandas"><meta name=twitter:description content="What it is, why it crops up, and how to get rid of it"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tnwei.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SettingWithCopyWarning in pandas","item":"https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SettingWithCopyWarning in pandas","name":"SettingWithCopyWarning in pandas","description":"What it is, why it crops up, and how to get rid of it","keywords":["python","pandas"],"articleBody":"(tl;dr: jump straight to Getting rid of SettingWithCopyWarnings if you’re here for answers)\nIf you are a pandas user, chances are you’ve seen the SettingWithCopyWarning crop up when you’re assigning values to a pd.DataFrame or pd.Series.\nIn [1]: import pandas as pd ...: ...: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: }, index=range(5) ...: ) ...: dfa = df.loc[3:5] ...: dfa[\"C\"] = dfa[\"B\"] * 50 \u003cipython-input-2-63497d1da3d9\u003e:9: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"C\"] = dfa[\"B\"] * 50 pandas drops a warning here because the value assignment might or might not have worked as expected.\nTo be clear, the value assignment did occur all right; the emphasis here is on “expected”.\nIn [2]: dfa Out[2]: A B C 3 4 9 450 4 5 10 500 In [3]: df Out[3]: A B 0 1 6 1 2 7 2 3 8 3 4 9 4 5 10 Did you expect the contents of df to be affected by the value assignment in dfa? pandas has internally consistent (albeit obtuse) rules on whether that happens or not. It’s just that the ambiguity in user expectations present in this situation warrants a warning, so that end users like you and me know where to look when our code misbehaves.\nChained assignment with views and copies The act of selecting rows or columns to access from a dataframe or series is called indexing. The flexibility of pandas allows for chained indexing, where you can repeatedly index the outcome of a previous indexing operation.\n# Select the 2nd to 4th row of data where col A \u003e 3 and col B != 7 df[df[\"A\"] \u003e 3 \u0026 df[\"B\"] != 7].iloc[3:5] pandas will then return either a view or a copy of the dataframe. A view (shallow copy) references data from the original dataframe, while a copy (deep copy) is a separate instance of the same data.\nIt is difficult to predict which will be returned by the indexing operation, as it depends on the memory layout of the underlying array. How exactly the indexing is chained can lead to different __getitem__ and __setitem__ calls being issued under the hood. Reproducing an example below:\n# Example borrowed from [1] dfmi.loc[:, ('one', 'second')] = value # becomes dfmi.loc.__setitem__((slice(None), ('one', 'second')), value) dfmi['one']['second'] = value # becomes dfmi.__getitem__('one').__setitem__('second', value) Chain indexing inherently is not a problem, but assigning values using chained indexing, i.e. chained assignment, can be. Depending on the situation, chained assignment will either modify the original dataframe directly, or return a modified copy of the original dataframe. This can lead to insidious bugs when it is not obvious that chained indexing has occured.\nChained indexing can take places across a few lines of code:\n# The following doesn't look like chain indexing, does it? dfa = df.loc[row1:row2, col1:col2] ... ... dfa[row2] = dfa[row1].apply(fn) If pandas did not raise a warning in this scenario, it would not be obvious that df is not modified by the second value assignment. This is why the SettingWithCopyWarning exists.\npandas docs 1 go into this with more detail. The warning message helpfully links to it, which is great because if you search pandas settingwithcopywarning on Google, the docs page is easy to miss! At time of writing, it is the 7th result on the first page of Google, and is crowded out by blogposts and StackOverflow questions.\nPeeking under the hood using the internal API Chained indexing is a godsend of convenience for selecting the right data, but chained assignment is a minefield for assigning the correct values. The TowardsDataScience article in 2 has a nice example where inverting the order of chained indexing alone is the difference between whether an assignment to the original dataframe occurs or not:\n# Example borrowed from [2] # This updates `df` df[\"product_group\"][df[\"product_group\"]==\"PG4\"] = \"PG14\" # This doesn't! df[df[\"product_group\"]==\"PG4\"][\"product_group\"] = \"PG14\" # pandas raises warnings for both # the user needs to confirm the intended outcome From this StackOverflow post, pd.DataFrame and pd.Series objects have _is_view and _is_copy attributes as part of their internal API. _is_view returns True if the object is a view, and False if the object is not. _is_copy stores either a weak reference to the dataframe it is copied from, or None if it is not associated to an existing dataframe.\nPrinting these internal attributes while poking around with chained assignment does reveal some interesting tidbits of info. On one hand, pandas uses _is_copy to decide if a SettingWithCopyWarning needs to be raised. On the other hand, modifying a dataframe with _is_view = True means that it will affect the original underlying dataframe.\nBefore we begin, a disclaimer: internal APIs are not meant to be accessed by the end user and are subject to change, use them at your own risk.\nIn [4]: pd.__version__ Out[4]: '1.3.3' # Setting up convenience functions In [5]: def make_clean_df(): ...: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5) ...: ) ...: return df In [6]: def show_attrs(obj): ...: print(f\"view: {obj._is_view}, copy: {obj._is_copy}\") We’ll start by showing the _is_view and _is_copy attributes of a few common indexing methods.\nIn [7]: df = make_clean_df() In [8]: show_attrs(df.loc[3:5]) ...: show_attrs(df.iloc[3:5]) ...: show_attrs(df.loc[3:5, [\"A\", \"B\"]]) ...: show_attrs(df.iloc[3:5, [0, 1]]) ...: show_attrs(df[\"A\"]) ...: show_attrs(df.loc[:, \"A\"]) view: True, copy: \u003cweakref at 0x7f4d648b2590; to 'DataFrame' at 0x7f4d648b54c0\u003e view: True, copy: \u003cweakref at 0x7f4d648b2590; to 'DataFrame' at 0x7f4d648b54c0\u003e view: False, copy: None view: False, copy: \u003cweakref at 0x7f4d648be770; dead\u003e view: True, copy: None view: True, copy: None Let’s break this down:\nBoth df.loc[3:5] and df.iloc[3:5] returned views and have references to the original dataframe. For df.loc[3:5, [\"A\", \"B\"]] and df.iloc[3:5, [0, 1]] , when the columns are additionally specified on top of the rows, copies of df are returned instead. Using .loc indexing has no references to the OG dataframe, while using iloc indexing results in a reference to a temporary dataframe that has been garbage collected, which is as good as None itself. We’ll see if this carries any significance. Referring to a column directly using either df[\"A\"] or df.loc[:, \"A\"] returns a view, with no reference to the original dataframe. It might have to do with the fact that each dataframe column is actually stored as a pd Series. What happens if we manually create copies of these indexed dataframes / series?\nIn [9]: show_attrs(df.loc[3:5].copy()) ...: show_attrs(df.iloc[3:5].copy()) ...: show_attrs(df.loc[3:5, [\"A\", \"B\"]].copy()) ...: show_attrs(df.iloc[3:5, [0, 1]].copy()) ...: show_attrs(df[\"A\"].copy()) ...: show_attrs(df.loc[:, \"A\"].copy()) view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None view: False, copy: None Explicitly calling .copy returns copies of data that have no reference to the original dataframe / series. Assigning data on these copies will not affect the original dataframe, and thus will not trigger SettingwithCopyWarnings. Given that df.loc[3:5, [\"A\", \"B\"]] and df.iloc[3:5, [0, 1]] above have similar attributes, we can expect that their behaviour under chained assignment should be similar to explicitly created copies.\nNext, we’ll try a few chained assignment scenarios.\nScenario 1: Specific rows indexed using loc The following three chained assignments raise SettingWithCopyWarnings:\nIn [10]: df = make_clean_df() ...: dfa = df.loc[3:5] ...: show_attrs(dfa) view: True, copy: \u003cweakref at 0x7fba308565e0; to 'DataFrame' at 0x7fba3084eac0\u003e # (1a) In [11]: dfa[dfa % 2 == 0] = 100 /tmp/ipykernel_34555/3321004726.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[dfa % 2 == 0] = 100 /home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/ frame.py:3718: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy self._where(-key, value, inplace=True) # (1b) In [12]: dfa[\"D\"] = dfa[\"B\"] * 10 /tmp/ipykernel_34555/447367411.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"D\"] = dfa[\"B\"] * 10 # 1b # (1c) In [13]: dfa[\"A\"][3] = 10 /tmp/ipykernel_34555/1338713145.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfa[\"A\"][3] = 10 All of the value assignments took effect on dfa itself, but only (1a) and (1c) affected the original dataframe. (1b) did not.\nIn [14]: print(dfa) A B C D 3 10 9 100 90 4 5 100 15 1000 In [15]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 In addition, dfa is no longer a view, but a copy of the dataframe!\nIn [16]: show_attrs(dfa) # view changed to False view: False, copy: \u003cweakref at 0x7fba308565e0; to 'DataFrame' at 0x7fba3084eac0\u003e What this tells us is that pandas will convert a view to a copy when necessary. This further shows why figuring out chained assignment is inherently tricky, and is difficult to cater for automatically at the library level.\nScenario 2: Specific rows indexed using iloc This is the same as scenario 1, but using iloc instead.\nIn [17]: df = make_clean_df() ...: dfb = df.iloc[3:5] ...: show_attrs(dfb) view: True, copy: \u003cweakref at 0x7fba30862040; to 'DataFrame' at 0x7fba30868c10\u003e # (1a) In [18]: dfb[dfb % 2 == 0] = 100 /tmp/ipykernel_34555/734837801.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[dfb % 2 == 0] = 100 /home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/ frame.py:3718: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy self._where(-key, value, inplace=True) # (1b) In [19]: dfb[\"D\"] = dfb[\"B\"] * 10 /tmp/ipykernel_34555/4288697762.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[\"D\"] = dfb[\"B\"] * 10 # (1c) In [20]: dfb[\"A\"][3] = 10 /tmp/ipykernel_34555/2062795903.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/ stable/user_guide/indexing.html#returning-a-view-versus-a-copy dfb[\"A\"][3] = 10 The observed outcome is the same as Scenario 1.\nIn [21]: print(dfb) A B C D 3 10 9 100 90 4 5 100 15 1000 In [22]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 In [23]: show_attrs(dfb) view: False, copy: \u003cweakref at 0x7fba30862040; to 'DataFrame' at 0x7fba30868c10\u003e Scenario 3: Specific rows and columns indexed using loc Same as Scenario 1, but the columns are specified as well.\nIn [24]: df = make_clean_df() ...: dfc = df.loc[3:5, [\"A\", \"B\"]] ...: show_attrs(dfc) view: False, copy: None In [25]: dfc[dfc % 2 == 0] = 100 # No warnings raised ...: dfc[\"D\"] = dfc[\"B\"] * 10 ...: dfc[\"A\"][3] = 10 No warnings raised. All changes took effect on dfc without impacting df.\nIn [26]: print(dfc) A B D 3 10 9 90 4 5 100 1000 In [27]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 10 9 100 4 5 100 15 The chained assignment outcome is different, while the data indexed is the same as in Scenario 1. My guess is that a more complete description of the indexing operation prompted pandas to directly return a copy upfront, instead of a view that is linked to the original dataframe.\nScenario 4: Specific rows and columns indexed using iloc This is similar to Scenario 3, but using iloc instead. Given the past few scenarios, it is no surprise that this scenario had the same outcome as Scenario 3.\nIn [28]: df = make_clean_df() ...: dfd = df.iloc[3:5, [0, 1]] ...: show_attrs(dfd) view: False, copy: \u003cweakref at 0x7fba306f29f0; dead\u003e In [29]: dfd[dfd % 2 == 0] = 100 # No warnings raised ...: dfd[\"D\"] = dfd[\"B\"] * 10 ...: dfd[\"A\"][3] = 10 In [30]: print(dfd) A B D 3 10 9 90 4 5 100 1000 In [31]: print(df) A B C 0 1 6 11 1 2 7 12 2 3 8 13 3 4 9 14 4 5 10 15 In addition, dfd discarded the reference to the garbage-collected dataframe at the end of this code.\nIn [32]: show_attrs(dfd) view: False, copy: None Scenario 5: Directly referring to a column of a dataframe This scenario tests chained assignment on series.\nIn [33]: df = make_clean_df() ...: dfe = df[\"A\"] ...: show_attrs(dfe) view: True, copy: None In [34]: dfe[1] = 99999 # No warnings raised ...: dfe.loc[2:4] = 88888 dfe remained a view of df[\"A\"]. All changes effected on dfe is reflected in df[\"A\"] , which is still part of df. It appears that there’s not much to worry about for chained assignment on individual series.\nIn [35]: print(dfe) 0 1 1 99999 2 88888 3 88888 4 88888 Name: A, dtype: int64 In [36]: print(df) A B C 0 1 6 11 1 99999 7 12 2 88888 8 13 3 88888 9 14 4 88888 10 15 In [37]: show_attrs(dfe) view: True, copy: None Getting rid of SettingWithCopyWarnings SettingWithCopyWarnings pop up when pandas isn’t sure if you want value assignment to affect the original dataframe or not. Therefore, getting rid of these warnings entails avoiding ambiguity in value assignment. As seen from the code samples above, getting pandas to return copies with no reference to the original dataframe is a clean way to ensure that values will not be written to the original dataframe unintended.\nI’ve found this to be a unifying thread across the solutions I came across when researching this topic. Summarizing them below:\nDisabling the warnings If you know what you’re doing and your code is behaving as intended, you can choose to suppress the warnings by disabling them 3:\n# Example borrowed from [^3] # Disables SettingWithCopyWarning globally pd.set_option('mode.chained_assignment', None) # Resets the warning option to default pd.reset_option('mode.chained_assignment') # Disables SettingWithCopyWarning locally within a context manager with pd.option_context('mode.chained_assignment', None): # YOUR CODE HERE Alternatively, you can suppress the warnings by setting the dataframe _is_copy attribute to None 3.\n# Example modified from [3] In [38]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) ...: ...: dfa = df.loc[3:5] ...: print(dfa._is_copy) \u003cweakref at 0x7f4d64792810; to 'DataFrame' at 0x7f4d64784460\u003e In [39]: dfa._is_copy = None ...: dfa[\"D\"] = dfa[\"B\"] * 10 # No warning raised Remember that making the warnings go away doesn’t resolve wonky chained assignment issues. Chained assignment is a minefield where you might or might not step on a landmine. Disabling the warnings is like removing the minefield warning signs. Food for thought.\nMaking the warnings not show up in the first place When you run into a SettingWithCopy warning, take a moment to trace the chained assignment and decide if you want to modify the original dataframe directly, or have values assigned to a copy of the dataframe.\nWorking on the original dataframe Use .loc indexing to directly assign values to the dataframe.\n# Modified from examples in [2] In [40]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) ...: ...: df.loc[df[\"A\"] % 2 != 0, \"B\"] = df.loc[df[\"A\"] % 2 != 0, \"B\"] + 0.5 ...: print(df) A B C 0 1 6.5 11 1 2 7.0 12 2 3 8.5 13 3 4 9.0 14 4 5 10.5 15 pandas docs recommend this method for two reasons:\nusing .loc is guaranteed to refer to the underlying dataframe it is called on. .iloc does not have this property. .loc indexing replaces what could be chain indexing into a single indexing step. If you refer to the example above under Chained assignment with views and copies, .loc indexing resolves chained indexing into a single __setitem__ call. If you are selecting data using conditionals, you can consider returning a mask instead of a copy of the original dataframe. A mask is a boolean series or dataframe which can conveniently be used in .loc indexing, as the example below:\n# Modified from examples in [5] In [41]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) In [42]: dfa = (df[\"A\"] \u003c= 3) \u0026 (df[\"C\"] == 12) In [43]: df.loc[dfa, \"B\"] = 99 # dfa can be fed into the loc index! In [44]: print(df) # changes took place in the original dataframe A B C 0 1 6 11 1 2 99 12 2 3 8 13 3 4 9 14 4 5 10 15 Working on the original dataframe directly can be tricky if existing indexing logic is complex. In that case, you can always use one of the methods from the next section to return a copy, then assign it back to the original dataframe 4.\nAssigning values to an explicit copy of the dataframe Use assign, where and replace:\nIn [45]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) # 1. Use the `assign` method to add columns In [46]: df = df.assign(D=df[\"C\"] * 10) ...: df = df.assign(**{\"D\": df[\"C\"] * 10}) # allows passing variables as names # 2. Use the `where` method to select values using conditionals and replace them # Modified from examples in [2] In [47]: df[\"B\"] = df[\"B\"].where( ...: df[\"A\"] \u003c 2, df[\"B\"] * 10 ...: ) # 3. Use the `replace` method to select and replace values in the dataframe # Modified from examples in [2] In [48]: df = df.replace({\"A\" : 1}, 100) In [49]: print(df) A B C D 0 100 6 11 110 1 2 70 12 120 2 3 80 13 130 3 4 90 14 140 4 5 100 15 150 Break down chained assignment steps into single assignments 5:\n# Examples borrowed from [4] # Not these df[\"z\"][mask] = 0 df.loc[mask][\"z\"] = 0 # But this df.loc[mask, \"z\"] = 0 A less elegant but foolproof method is to manually create a copy of the original dataframe and work on it instead 2. As long as you don’t introduce additional chained indexing, you will not see the SettingWithCopyWarning.\nIn [50]: df = pd.DataFrame({ ...: \"A\": [1, 2, 3, 4, 5], ...: \"B\": [6, 7, 8, 9, 10], ...: \"C\": [11, 12, 13, 14, 15], ...: }, index=range(5)) In [51]: dfa = df.loc[3:5].copy() # Added .copy() here ...: dfa.loc[3, \"A\"] = 10 # causes this line to raise no warning Redoing some of the examples above without triggering SettingWithCopy warnings Replace a chained assignment with where:\n# (i) df = make_clean_df() dfa = df.loc[3:5] # Original that raises warning # dfa[dfa % 2 == 0] = 100 dfa = dfa.where(dfa % 2 != 0, 100) # df is not affected Replace creating a new column on the indexed dataframe with assign:\n# (ii) df = make_clean_df() # Original that raises warning # dfa[\"D\"] = dfa[\"B\"] * 10 dfa = dfa.assign(D=dfa[\"B\"]*10) # df is not affected Creating a copy of the dataframe, before assigning values using .loc indexing:\n# (iii) df = make_clean_df() # Original that raises warnings # dfa = df.loc[3:5] # dfa[\"A\"][3] = 10 # Create a copy then do loc indexing dfa = df.loc[3:5].copy() dfa.loc[3, \"A\"] = 10 Note that directly assigning values to dfa using .loc indexing will still raise a warning, as it is ambiguous if the assignment to dfa should also affect df.\nTruly rooting out SettingWithCopyWarnings Personally, I am a fan of promoting SettingWithCopyWarnings to SettingWithCopyExceptions for important scripts, using the following code:\npd.set_option('mode.chained_assignment', \"raise\") Doing this forces chained assignment to be dealt with, rather than allowing warnings to accumulate.\nIn my experience, cleaning up notebooks with stderr clogged by SettingWithCopyWarnings is its special kind of zen. I wholeheartedly recommend it.\nOfficial pandas docs on chained assignment. https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy ↩︎\nTowardsDataScience article that briefly touches on a few ways to deal with the SettingWithCopy warnings. https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08 ↩︎ ↩︎\nIn-depth article on this topic by DataQuest. Notably, there is a section dedicated to the history of dealing with chained assignment in pandas. https://www.dataquest.io/blog/settingwithcopywarning/ ↩︎ ↩︎\nStackOverflow post that contains more chained assignment examples. https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe ↩︎\nRealPython article covering this topic. For me, RealPython is a trusted goto reference second to official library docs. This article further goes into depth on the underlying view vs copy mechanisms in pandas, and in numpy, which pandas depends on. https://realpython.com/pandas-settingwithcopywarning/ ↩︎\n","wordCount":"3497","inLanguage":"en","datePublished":"2021-12-30T00:40:54+08:00","dateModified":"2021-12-30T00:40:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tnwei.github.io/posts/setting-with-copy-warning-pandas/"},"publisher":{"@type":"Organization","name":"Tan Nian Wei","logo":{"@type":"ImageObject","url":"https://tnwei.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://tnwei.github.io/ accesskey=h title="Tan Nian Wei (Alt + H)">Tan Nian Wei</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://tnwei.github.io/writing/ title=Writing><span>Writing</span></a></li><li><a href="https://drive.google.com/file/d/1kWKGkamiCd7RZLssEBy3b-FT3r0jpwha/view?usp=sharing" title=Resume><span>Resume</span></a></li><li><a href=https://tnwei.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SettingWithCopyWarning in pandas</h1><div class=post-meta><span title='2021-12-30 00:40:54 +0800 +0800'>Dec 30, 2021 Thu</span>&nbsp;·&nbsp;17 min</div></header><div class=post-content><p>(tl;dr: jump straight to <a href=#getting-rid-of-settingwithcopywarnings title="Getting rid of SettingWithCopyWarnings">Getting rid of SettingWithCopyWarnings</a> if you’re here for answers)</p><p>If you are a pandas user, chances are you’ve seen the SettingWithCopyWarning crop up when you’re assigning values to a <code>pd.DataFrame</code> or <code>pd.Series</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>1</span>]: <span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:      }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: )
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: dfa[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>ipython<span style=color:#f92672>-</span>input<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>-</span><span style=color:#ae81ff>63497</span>d1da3d9<span style=color:#f92672>&gt;</span>:<span style=color:#ae81ff>9</span>: SettingWithCopyWarning:
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfa[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>
</span></span></code></pre></div><p>pandas drops a warning here because the value assignment might or might not have worked as expected.</p><p>To be clear, the value assignment did occur all right; the emphasis here is on “expected”.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>2</span>]: dfa
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>2</span>]:
</span></span><span style=display:flex><span>   A   B    C
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>450</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>3</span>]: df
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>3</span>]:
</span></span><span style=display:flex><span>   A   B
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>Did you expect the contents of <code>df</code> to be affected by the value assignment in <code>dfa</code>? pandas has internally consistent (albeit obtuse) rules on whether that happens or not. It’s just that the ambiguity in user expectations present in this situation warrants a warning, so that end users like you and me know where to look when our code misbehaves.</p><h2 id=chained-assignment-with-views-and-copies>Chained assignment with views and copies<a hidden class=anchor aria-hidden=true href=#chained-assignment-with-views-and-copies>#</a></h2><p>The act of selecting rows or columns to access from a dataframe or series is called <em>indexing</em>. The flexibility of pandas allows for chained indexing, where you can repeatedly index the outcome of a previous indexing operation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Select the 2nd to 4th row of data where col A &gt; 3 and col B != 7</span>
</span></span><span style=display:flex><span>df[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;</span> df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>7</span>]<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span></code></pre></div><p>pandas will then return either a view or a copy of the dataframe. A view (shallow copy) references data from the original dataframe, while a copy (deep copy) is a separate instance of the same data.</p><p>It is difficult to predict which will be returned by the indexing operation, as it depends on the memory layout of the underlying array. How exactly the indexing is chained can lead to different <code>__getitem__</code> and <code>__setitem__</code> calls being issued under the hood. Reproducing an example below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Example borrowed from [1]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfmi<span style=color:#f92672>.</span>loc[:, (<span style=color:#e6db74>&#39;one&#39;</span>, <span style=color:#e6db74>&#39;second&#39;</span>)] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span><span style=color:#75715e># becomes</span>
</span></span><span style=display:flex><span>dfmi<span style=color:#f92672>.</span>loc<span style=color:#f92672>.</span>__setitem__((slice(<span style=color:#66d9ef>None</span>), (<span style=color:#e6db74>&#39;one&#39;</span>, <span style=color:#e6db74>&#39;second&#39;</span>)), value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfmi[<span style=color:#e6db74>&#39;one&#39;</span>][<span style=color:#e6db74>&#39;second&#39;</span>] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span><span style=color:#75715e># becomes</span>
</span></span><span style=display:flex><span>dfmi<span style=color:#f92672>.</span>__getitem__(<span style=color:#e6db74>&#39;one&#39;</span>)<span style=color:#f92672>.</span>__setitem__(<span style=color:#e6db74>&#39;second&#39;</span>, value)
</span></span></code></pre></div><p>Chain indexing inherently is not a problem, but assigning values using chained indexing, i.e. <em>chained assignment</em>, can be. Depending on the situation, chained assignment will either modify the original dataframe directly, or return a modified copy of the original dataframe. This can lead to insidious bugs when it is not obvious that chained indexing has occured.</p><p>Chained indexing can take places across a few lines of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># The following doesn&#39;t look like chain indexing, does it?</span>
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[row1:row2, col1:col2]
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>dfa[row2] <span style=color:#f92672>=</span> dfa[row1]<span style=color:#f92672>.</span>apply(fn)
</span></span></code></pre></div><p>If pandas did not raise a warning in this scenario, it would not be obvious that <code>df</code> is not modified by the second value assignment. This is why the SettingWithCopyWarning exists.</p><p>pandas docs <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> go into this with more detail. The warning message helpfully links to it, which is great because if you search <code>pandas settingwithcopywarning</code> on Google, the docs page is easy to miss! At time of writing, it is the 7th result on the first page of Google, and is crowded out by blogposts and StackOverflow questions.</p><h2 id=peeking-under-the-hood-using-the-internal-api>Peeking under the hood using the internal API<a hidden class=anchor aria-hidden=true href=#peeking-under-the-hood-using-the-internal-api>#</a></h2><p>Chained indexing is a godsend of convenience for selecting the right data, but chained assignment is a minefield for assigning the correct values. The TowardsDataScience article in <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> has a nice example where inverting the order of chained indexing alone is the difference between whether an assignment to the original dataframe occurs or not:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Example borrowed from [2]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This updates `df`</span>
</span></span><span style=display:flex><span>df[<span style=color:#e6db74>&#34;product_group&#34;</span>][df[<span style=color:#e6db74>&#34;product_group&#34;</span>]<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;PG4&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;PG14&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This doesn&#39;t!</span>
</span></span><span style=display:flex><span>df[df[<span style=color:#e6db74>&#34;product_group&#34;</span>]<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;PG4&#34;</span>][<span style=color:#e6db74>&#34;product_group&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;PG14&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># pandas raises warnings for both</span>
</span></span><span style=display:flex><span><span style=color:#75715e># the user needs to confirm the intended outcome</span>
</span></span></code></pre></div><p>From <a href=https://stackoverflow.com/questions/26879073/checking-whether-data-frame-is-copy-or-view-in-pandas>this StackOverflow post</a>, <code>pd.DataFrame</code> and <code>pd.Series</code> objects have <code>_is_view</code> and <code>_is_copy</code> attributes as part of their internal API. <code>_is_view</code> returns True if the object is a view, and False if the object is not. <code>_is_copy</code> stores either a <a href=https://docs.python.org/3/library/weakref.html>weak reference</a> to the dataframe it is copied from, or <code>None</code> if it is not associated to an existing dataframe.</p><p>Printing these internal attributes while poking around with chained assignment does reveal some interesting tidbits of info. On one hand, pandas uses <code>_is_copy</code> to decide if a SettingWithCopyWarning needs to be raised. On the other hand, modifying a dataframe with <code>_is_view</code> = True means that it will affect the original underlying dataframe.</p><p>Before we begin, a disclaimer: internal APIs are not meant to be accessed by the end user and are subject to change, use them at your own risk.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>4</span>]: pd<span style=color:#f92672>.</span>__version__
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>4</span>]: <span style=color:#e6db74>&#39;1.3.3&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Setting up convenience functions</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>5</span>]: <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_clean_df</span>():
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:         <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:          }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     )
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     <span style=color:#66d9ef>return</span> df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>6</span>]: <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>show_attrs</span>(obj):
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>:     print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;view: </span><span style=color:#e6db74>{</span>obj<span style=color:#f92672>.</span>_is_view<span style=color:#e6db74>}</span><span style=color:#e6db74>, copy: </span><span style=color:#e6db74>{</span>obj<span style=color:#f92672>.</span>_is_copy<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>We’ll start by showing the <code>_is_view</code> and <code>_is_copy</code> attributes of a few common indexing methods.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>7</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>8</span>]: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]])
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]])
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df[<span style=color:#e6db74>&#34;A&#34;</span>])
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[:, <span style=color:#e6db74>&#34;A&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648b2590</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d648b54c0</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648b2590</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d648b54c0</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d648be770</span>; dead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><p>Let’s break this down:</p><ul><li>Both <code>df.loc[3:5]</code> and <code>df.iloc[3:5]</code> returned views and have references to the original dataframe.</li><li>For <code>df.loc[3:5, ["A", "B"]]</code> and <code>df.iloc[3:5, [0, 1]]</code> , when the columns are additionally specified on top of the rows, copies of <code>df</code> are returned instead. Using <code>.loc</code> indexing has no references to the OG dataframe, while using <code>iloc</code> indexing results in a reference to a temporary dataframe that has been garbage collected, which is as good as <code>None</code> itself. We’ll see if this carries any significance.</li><li>Referring to a column directly using either <code>df["A"]</code> or <code>df.loc[:, "A"]</code> returns a view, with no reference to the original dataframe. It might have to do with the fact that each dataframe column is actually stored as a <code>pd Series</code>.</li></ul><p>What happens if we manually create copies of these indexed dataframes / series?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>9</span>]: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df[<span style=color:#e6db74>&#34;A&#34;</span>]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>: show_attrs(df<span style=color:#f92672>.</span>loc[:, <span style=color:#e6db74>&#34;A&#34;</span>]<span style=color:#f92672>.</span>copy())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><p>Explicitly calling <code>.copy</code> returns copies of data that have no reference to the original dataframe / series. Assigning data on these copies will not affect the original dataframe, and thus will not trigger SettingwithCopyWarnings. Given that <code>df.loc[3:5, ["A", "B"]]</code> and <code>df.iloc[3:5, [0, 1]]</code> above have similar attributes, we can expect that their behaviour under chained assignment should be similar to explicitly created copies.</p><p>Next, we’ll try a few chained assignment scenarios.</p><h3 id=scenario-1-specific-rows-indexed-using-loc>Scenario 1: Specific rows indexed using loc<a hidden class=anchor aria-hidden=true href=#scenario-1-specific-rows-indexed-using-loc>#</a></h3><p>The following three chained assignments raise SettingWithCopyWarnings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>10</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: show_attrs(dfa)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba308565e0</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba3084eac0</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1a)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>11</span>]: dfa[dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>3321004726.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfa[dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>tnwei<span style=color:#f92672>/</span>miniconda3<span style=color:#f92672>/</span>envs<span style=color:#f92672>/</span>ml<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>python3<span style=color:#ae81ff>.9</span><span style=color:#f92672>/</span>site<span style=color:#f92672>-</span>packages<span style=color:#f92672>/</span>pandas<span style=color:#f92672>/</span>core<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>frame<span style=color:#f92672>.</span>py:<span style=color:#ae81ff>3718</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  self<span style=color:#f92672>.</span>_where(<span style=color:#f92672>-</span>key, value, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1b)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>12</span>]: dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>447367411.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> <span style=color:#75715e># 1b</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1c)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>13</span>]: dfa[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>1338713145.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfa[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>All of the value assignments took effect on <code>dfa</code> itself, but only (1a) and (1c) affected the original dataframe. (1b) did not.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>14</span>]: print(dfa)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>A    B    C     D
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>15</span>]: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A    B    C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>In addition, <code>dfa</code> is no longer a view, but a copy of the dataframe!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>16</span>]: show_attrs(dfa) <span style=color:#75715e># view changed to False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba308565e0</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba3084eac0</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>What this tells us is that pandas will convert a view to a copy when necessary. This further shows why figuring out chained assignment is inherently tricky, and is difficult to cater for automatically at the library level.</p><h3 id=scenario-2-specific-rows-indexed-using-iloc>Scenario 2: Specific rows indexed using iloc<a hidden class=anchor aria-hidden=true href=#scenario-2-specific-rows-indexed-using-iloc>#</a></h3><p>This is the same as scenario 1, but using <code>iloc</code> instead.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>17</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfb <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: show_attrs(dfb)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba30862040</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba30868c10</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1a)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>18</span>]: dfb[dfb <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>734837801.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfb[dfb <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>tnwei<span style=color:#f92672>/</span>miniconda3<span style=color:#f92672>/</span>envs<span style=color:#f92672>/</span>ml<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>python3<span style=color:#ae81ff>.9</span><span style=color:#f92672>/</span>site<span style=color:#f92672>-</span>packages<span style=color:#f92672>/</span>pandas<span style=color:#f92672>/</span>core<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>frame<span style=color:#f92672>.</span>py:<span style=color:#ae81ff>3718</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  self<span style=color:#f92672>.</span>_where(<span style=color:#f92672>-</span>key, value, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1b)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>19</span>]: dfb[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfb[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>4288697762.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>Try using <span style=color:#f92672>.</span>loc[row_indexer,col_indexer] <span style=color:#f92672>=</span> value instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfb[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfb[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (1c)</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>20</span>]: dfb[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>/</span>tmp<span style=color:#f92672>/</span>ipykernel_34555<span style=color:#f92672>/</span><span style=color:#ae81ff>2062795903.</span>py:<span style=color:#ae81ff>1</span>: SettingWithCopyWarning: 
</span></span><span style=display:flex><span>A value <span style=color:#f92672>is</span> trying to be set on a copy of a slice <span style=color:#f92672>from</span> a DataFrame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>See the caveats <span style=color:#f92672>in</span> the documentation: https:<span style=color:#f92672>//</span>pandas<span style=color:#f92672>.</span>pydata<span style=color:#f92672>.</span>org<span style=color:#f92672>/</span>pandas<span style=color:#f92672>-</span>docs<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>stable<span style=color:#f92672>/</span>user_guide<span style=color:#f92672>/</span>indexing<span style=color:#f92672>.</span>html<span style=color:#75715e>#returning-a-view-versus-a-copy</span>
</span></span><span style=display:flex><span>  dfb[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>The observed outcome is the same as Scenario 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>21</span>]: print(dfb)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A    B    C     D
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>22</span>]: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A    B    C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>23</span>]: show_attrs(dfb)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba30862040</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7fba30868c10</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h3 id=scenario-3-specific-rows-and-columns-indexed-using-loc>Scenario 3: Specific rows and columns indexed using loc<a hidden class=anchor aria-hidden=true href=#scenario-3-specific-rows-and-columns-indexed-using-loc>#</a></h3><p>Same as Scenario 1, but the columns are specified as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>24</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfc <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>]]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: show_attrs(dfc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>25</span>]: dfc[dfc <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#75715e># No warnings raised</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfc[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfc[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfc[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>No warnings raised. All changes took effect on <code>dfc</code> without impacting <code>df</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>26</span>]: print(dfc)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>A    B    D
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>   <span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span> <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>27</span>]: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A    B    C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>6</span>   <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>   <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>The chained assignment outcome is different, while the data indexed is the same as in Scenario 1. My guess is that a more complete description of the indexing operation prompted pandas to directly return a copy upfront, instead of a view that is linked to the original dataframe.</p><h3 id=scenario-4-specific-rows-and-columns-indexed-using-iloc>Scenario 4: Specific rows and columns indexed using iloc<a hidden class=anchor aria-hidden=true href=#scenario-4-specific-rows-and-columns-indexed-using-iloc>#</a></h3><p>This is similar to Scenario 3, but using iloc instead. Given the past few scenarios, it is no surprise that this scenario had the same outcome as Scenario 3.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>28</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfd <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>, [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: show_attrs(dfd)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7fba306f29f0</span>; dead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>29</span>]: dfd[dfd <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>  <span style=color:#75715e># No warnings raised</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfd[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfd[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfd[<span style=color:#e6db74>&#34;A&#34;</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>30</span>]: print(dfd)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A    B     D
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>9</span>    <span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>  <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>31</span>]: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A   B   C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>In addition, <code>dfd</code> discarded the reference to the garbage-collected dataframe at the end of this code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>32</span>]: show_attrs(dfd)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>False</span>, copy: <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><h3 id=scenario-5-directly-referring-to-a-column-of-a-dataframe>Scenario 5: Directly referring to a column of a dataframe<a hidden class=anchor aria-hidden=true href=#scenario-5-directly-referring-to-a-column-of-a-dataframe>#</a></h3><p>This scenario tests chained assignment on series.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>33</span>]: df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfe <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;A&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: show_attrs(dfe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>34</span>]: dfe[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99999</span> <span style=color:#75715e># No warnings raised</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfe<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>88888</span>
</span></span></code></pre></div><p><code>dfe</code> remained a view of <code>df["A"]</code>. All changes effected on <code>dfe</code> is reflected in <code>df["A"]</code> , which is still part of <code>df</code>. It appears that there’s not much to worry about for chained assignment on individual series.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>35</span>]: print(dfe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>99999</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>88888</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>88888</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>    <span style=color:#ae81ff>88888</span>
</span></span><span style=display:flex><span>Name: A, dtype: int64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>36</span>]: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A   B   C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>99999</span>   <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>88888</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>88888</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>88888</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>37</span>]: show_attrs(dfe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>view: <span style=color:#66d9ef>True</span>, copy: <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><h2 id=getting-rid-of-settingwithcopywarnings>Getting rid of SettingWithCopyWarnings<a hidden class=anchor aria-hidden=true href=#getting-rid-of-settingwithcopywarnings>#</a></h2><p>SettingWithCopyWarnings pop up when pandas isn’t sure if you want value assignment to affect the original dataframe or not. Therefore, getting rid of these warnings entails avoiding ambiguity in value assignment. As seen from the code samples above, getting pandas to return copies with no reference to the original dataframe is a clean way to ensure that values will not be written to the original dataframe unintended.</p><p>I’ve found this to be a unifying thread across the solutions I came across when researching this topic. Summarizing them below:</p><h3 id=disabling-the-warnings>Disabling the warnings<a hidden class=anchor aria-hidden=true href=#disabling-the-warnings>#</a></h3><p>If you know what you’re doing and your code is behaving as intended, you can choose to suppress the warnings by disabling them <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Example borrowed from [^3]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Disables SettingWithCopyWarning globally</span>
</span></span><span style=display:flex><span>pd<span style=color:#f92672>.</span>set_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Resets the warning option to default</span>
</span></span><span style=display:flex><span>pd<span style=color:#f92672>.</span>reset_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Disables SettingWithCopyWarning locally within a context manager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> pd<span style=color:#f92672>.</span>option_context(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># YOUR CODE HERE</span>
</span></span></code></pre></div><p>Alternatively, you can suppress the warnings by setting the dataframe <code>_is_copy</code> attribute to <code>None</code> <sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Example modified from [3]</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>38</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: 
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: print(dfa<span style=color:#f92672>.</span>_is_copy)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>weakref at <span style=color:#ae81ff>0x7f4d64792810</span>; to <span style=color:#e6db74>&#39;DataFrame&#39;</span> at <span style=color:#ae81ff>0x7f4d64784460</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>39</span>]: dfa<span style=color:#f92672>.</span>_is_copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfa[<span style=color:#e6db74>&#34;D&#34;</span>] <span style=color:#f92672>=</span> dfa[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># No warning raised</span>
</span></span></code></pre></div><p>Remember that making the warnings go away doesn’t resolve wonky chained assignment issues. Chained assignment is a minefield where you might or might not step on a landmine. Disabling the warnings is like removing the minefield warning signs. Food for thought.</p><h3 id=making-the-warnings-not-show-up-in-the-first-place>Making the warnings not show up in the first place<a hidden class=anchor aria-hidden=true href=#making-the-warnings-not-show-up-in-the-first-place>#</a></h3><p>When you run into a SettingWithCopy warning, take a moment to trace the chained assignment and decide if you want to modify the original dataframe directly, or have values assigned to a copy of the dataframe.</p><h4 id=working-on-the-original-dataframe>Working on the original dataframe<a hidden class=anchor aria-hidden=true href=#working-on-the-original-dataframe>#</a></h4><p>Use <code>.loc</code> indexing to directly assign values to the dataframe.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Modified from examples in [2]</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>40</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   A     B   C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6.5</span>  <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>7.0</span>  <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8.5</span>  <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9.0</span>  <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10.5</span>  <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>pandas docs recommend this method for two reasons:</p><ul><li>using <code>.loc</code> is guaranteed to refer to the underlying dataframe it is called on. <code>.iloc</code> does not have this property.</li><li><code>.loc</code> indexing replaces what could be chain indexing into a single indexing step. If you refer to the example above under <a href=#chained-assignment-with-views-and-copies title="Chained assignment with views and copies">Chained assignment with views and copies</a>, <code>.loc</code> indexing resolves chained indexing into a single <code>__setitem__</code> call.</li></ul><p>If you are selecting data using conditionals, you can consider returning a mask instead of a copy of the original dataframe. A mask is a boolean series or dataframe which can conveniently be used in <code>.loc</code> indexing, as the example below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Modified from examples in [5]</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>41</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>42</span>]: dfa <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&amp;</span> (df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>43</span>]: df<span style=color:#f92672>.</span>loc[dfa, <span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99</span> <span style=color:#75715e># dfa can be fed into the loc index!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>44</span>]: print(df) <span style=color:#75715e># changes took place in the original dataframe</span>
</span></span><span style=display:flex><span>   A   B   C
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>99</span>  <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>10</span>  <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>Working on the original dataframe directly can be tricky if existing indexing logic is complex. In that case, you can always use one of the methods from the next section to return a copy, then assign it back to the original dataframe <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><h4 id=assigning-values-to-an-explicit-copy-of-the-dataframe>Assigning values to an explicit copy of the dataframe<a hidden class=anchor aria-hidden=true href=#assigning-values-to-an-explicit-copy-of-the-dataframe>#</a></h4><p>Use <code>assign</code>, <code>where</code> and <code>replace</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>45</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. Use the `assign` method to add columns</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>46</span>]: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>assign(D<span style=color:#f92672>=</span>df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>assign(<span style=color:#f92672>**</span>{<span style=color:#e6db74>&#34;D&#34;</span>: df[<span style=color:#e6db74>&#34;C&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>}) <span style=color:#75715e># allows passing variables as names</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. Use the `where` method to select values using conditionals and replace them</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Modified from examples in [2]</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>47</span>]: df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;B&#34;</span>]<span style=color:#f92672>.</span>where(
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     df[<span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>, df[<span style=color:#e6db74>&#34;B&#34;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. Use the `replace` method to select and replace values in the dataframe</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Modified from examples in [2]</span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>48</span>]: df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>replace({<span style=color:#e6db74>&#34;A&#34;</span> : <span style=color:#ae81ff>1</span>}, <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>49</span>]: print(df)
</span></span><span style=display:flex><span>A    B   C    D
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>100</span>    <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span>  <span style=color:#ae81ff>110</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>70</span>  <span style=color:#ae81ff>12</span>  <span style=color:#ae81ff>120</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>    <span style=color:#ae81ff>3</span>   <span style=color:#ae81ff>80</span>  <span style=color:#ae81ff>13</span>  <span style=color:#ae81ff>130</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>90</span>  <span style=color:#ae81ff>14</span>  <span style=color:#ae81ff>140</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>    <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>100</span>  <span style=color:#ae81ff>15</span>  <span style=color:#ae81ff>150</span>
</span></span></code></pre></div><p>Break down chained assignment steps into single assignments <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Examples borrowed from [4]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Not these</span>
</span></span><span style=display:flex><span>df[<span style=color:#e6db74>&#34;z&#34;</span>][mask] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>loc[mask][<span style=color:#e6db74>&#34;z&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># But this</span>
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>loc[mask, <span style=color:#e6db74>&#34;z&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>A less elegant but foolproof method is to manually create a copy of the original dataframe and work on it instead <sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. As long as you don’t introduce additional chained indexing, you will not see the SettingWithCopyWarning.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>50</span>]: df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>:     <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: }, index<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>51</span>]: dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy() <span style=color:#75715e># Added .copy() here</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>: dfa<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>     <span style=color:#75715e># causes this line to raise no warning</span>
</span></span></code></pre></div><h2 id=redoing-some-of-the-examples-above-without-triggering-settingwithcopy-warnings>Redoing some of the examples above without triggering SettingWithCopy warnings<a hidden class=anchor aria-hidden=true href=#redoing-some-of-the-examples-above-without-triggering-settingwithcopy-warnings>#</a></h2><p>Replace a chained assignment with <code>where</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (i)</span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Original that raises warning</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dfa[dfa % 2 == 0] = 100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> dfa<span style=color:#f92672>.</span>where(dfa <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>) <span style=color:#75715e># df is not affected</span>
</span></span></code></pre></div><p>Replace creating a new column on the indexed dataframe with <code>assign</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (ii) </span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Original that raises warning</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dfa[&#34;D&#34;] = dfa[&#34;B&#34;] * 10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> dfa<span style=color:#f92672>.</span>assign(D<span style=color:#f92672>=</span>dfa[<span style=color:#e6db74>&#34;B&#34;</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>) <span style=color:#75715e># df is not affected</span>
</span></span></code></pre></div><p>Creating a copy of the dataframe, before assigning values using <code>.loc</code> indexing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># (iii)</span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> make_clean_df()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Original that raises warnings</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dfa = df.loc[3:5]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dfa[&#34;A&#34;][3] = 10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create a copy then do loc indexing</span>
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>5</span>]<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>dfa<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;A&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>Note that directly assigning values to <code>dfa</code> using <code>.loc</code> indexing will still raise a warning, as it is ambiguous if the assignment to <code>dfa</code> should also affect <code>df</code>.</p><h2 id=truly-rooting-out-settingwithcopywarnings>Truly rooting out SettingWithCopyWarnings<a hidden class=anchor aria-hidden=true href=#truly-rooting-out-settingwithcopywarnings>#</a></h2><p>Personally, I am a fan of promoting SettingWithCopyWarnings to SettingWithCopyExceptions for important scripts, using the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>pd<span style=color:#f92672>.</span>set_option(<span style=color:#e6db74>&#39;mode.chained_assignment&#39;</span>, <span style=color:#e6db74>&#34;raise&#34;</span>)
</span></span></code></pre></div><p>Doing this forces chained assignment to be dealt with, rather than allowing warnings to accumulate.</p><p>In my experience, cleaning up notebooks with stderr clogged by SettingWithCopyWarnings is its special kind of zen. I wholeheartedly recommend it.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Official <code>pandas</code> docs on chained assignment.
<a href=https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy>https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>TowardsDataScience article that briefly touches on a few ways to deal with the SettingWithCopy warnings.
<a href=https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08>https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>In-depth article on this topic by DataQuest. Notably, there is a section dedicated to the history of dealing with chained assignment in <code>pandas</code>.
<a href=https://www.dataquest.io/blog/settingwithcopywarning/>https://www.dataquest.io/blog/settingwithcopywarning/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>StackOverflow post that contains more chained assignment examples. <a href=https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe>https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>RealPython article covering this topic. For me, RealPython is a trusted goto reference second to official library docs. This article further goes into depth on the underlying view vs copy mechanisms in pandas, and in numpy, which pandas depends on.
<a href=https://realpython.com/pandas-settingwithcopywarning/>https://realpython.com/pandas-settingwithcopywarning/</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://tnwei.github.io/tags/python/>python</a></li><li><a href=https://tnwei.github.io/tags/pandas/>pandas</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=tnwei/tnwei.github.io data-repo-id=R_kgDOGmOfvQ data-category=Announcements data-category-id=DIC_kwDOGmOfvc4CAeit data-mapping=og:title data-reactions-enabled=0 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script><noscript></noscript></article></main><footer class=footer><span>&copy; 2023 <a href=https://tnwei.github.io/>Tan Nian Wei</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>